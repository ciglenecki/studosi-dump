{
  "title": "[MREPRO] 4. domaća zadaća - 2019/2020",
  "creator": "Sashat_Triceps (Sasha_Triceps)",
  "slug": "mrepro-4-domaca-zadaca-20192020",
  "tags": [
    "FER",
    "Mrežno programiranje",
    "Zadaće"
  ],
  "posts": {
    "17859": {
      "poster": "Sashat_Triceps (Sasha_Triceps)",
      "content": "E kako definirati buffer za primanje RREQ zahtjeva? U specifikacijama kaže 2 bajta za code ( uint_16t), al onda za ime datoteke kaze samo \"string\" i kasnije isto tako za polje načina prijenosa. \n\nKoliko taj \"string\" mora biti velik? Jel postoji neki pametniji način od toga da uzmem char polje malo veće duljine i iz njega sa strtok odvojim ime datoteke i način prijenosa?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19758": {
      "poster": "Gussy (huba buba)",
      "content": "Jeste li napravili poseban struct za svaki mogući tip paketa?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19762": {
      "poster": "Gussy (huba buba)",
      "content": "@Sashat_Triceps#17859 Ne vidim ni u ovom RFC 1350 da igdje piše koliko dugačak mora biti taj string filename, pa stavi tipa 256 ili nešto tako. Mislim da to nije toliko bitno. Za međuispit i za ove labose itd., ja sam radio posebne structove za tipove paketa koji koristim u tom zadatku. Npr. struct za rip paket iz meduispita.\n\n```\nstruct rip_entry\n{\n    unsigned int af_identifier : 16;\n    unsigned int route_tag : 16;\n    unsigned int ip_address : 32;\n    unsigned int subnet_mask : 32;\n    unsigned int next_hop : 32;\n    unsigned int metric : 32;\n};   \n\nstruct rip_packet\n{\n    unsigned int command : 8;\n    unsigned int version : 8;\n    unsigned int must_be_zero : 16;\n    struct rip_entry entries[MAX_ENTRY];\n};\n```\nOvi brojevi pored svakog elementa structa se zovu bit field i označavaju koliko bitova zauzima taj element unutar samog structa, ako piše 16, to znači 2 bytea. Nisam siguran ako koristiš bit field za neki element unutar structa, da li onda svi elementi isto moraju koristiti bit fieldove ili mogu biti i elementi za koje nije definirana veličina bitova na ovaj način. \n\nTj. može li se ovako:\n\n\n```\nstruct foo\n{\n    int a : 16;\n    int b;\n}\n```\nPo nekoj logici ovaj int a bi bio veličine 2 bajta, a int b bi zauzimao normalnu količinu memorije koliko int zauzima. Pretpostavljam da i ovo radi.",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19784": {
      "poster": "Gussy (huba buba)",
      "content": "@Sashat_Triceps#17859 Lol sad sam skuzio o cemu pricas i ovaj moj odgovor nema veze s tim, al cu svejedno ostavit. Ionako ne mogu obrisat. \n\nNisam siguran kako bi se trebalo \"odvojiti\" taj string od ostatka poruke, tj. skuziti gdje zavrsava.\n\nhttps://github.com/crossbowerbt/tftpserver/blob/master/tftpserv.c\n\nOvdje je lik iskoristio `\\0` da nađe gdje završava filename.",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19951": {
      "poster": "Sashat_Triceps (Sasha_Triceps)",
      "content": "@Gussy#19784  Hvala ti na dužem odgovoru :)\n\nNapravio sam zadaću u međuvremenu, u biti sam puknuo char  polje \"Data\"velicine 100,  poslije codea od 2 bajta, pa se onda kasnije drkas sa izvlacenjem file namea i nacina prijenosa. Stvar je u tome sto oni nisu zapravo odvojeni sa tom nulom kao što je u specifikaciji. Kad sam testirao s wiresharkom odvojeni su s  \\0 , a 0 dolazi tek na kraju paketa, tako daa nez tko tu koga laže . Koristio sam isti delimiter ko taj lik i radi",
      "votes": {
        "upvoters": [
          "Gussy (huba buba)"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19953": {
      "poster": "Gussy (huba buba)",
      "content": "@Sashat_Triceps#19951 Ocu stici do sutra napisati sve? Ima milijun stvari koje se trebaju implementirati.",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19962": {
      "poster": "Sashat_Triceps (Sasha_Triceps)",
      "content": "@Gussy#19953 Pa ovisi koliko si napravio, najviše vremena će ti uzet obrada tekstualne datoteke za \\n -ove. Poslije toga ovo ostalo ide glatko",
      "votes": {
        "upvoters": [
          "Gussy (huba buba)"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19967": {
      "poster": "Gussy (huba buba)",
      "content": "@Sashat_Triceps#19962 Kako si riješio taj problem sa zamjenjivanjem \\n sa \\r\\n jer se ne treba \"samo\" zamijeniti kako oni kazu nego moras dodati jos jedan znak i onda cijela ta obrada ode u kurac.",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19972": {
      "poster": "Sashat_Triceps (Sasha_Triceps)",
      "content": "@Gussy#19967 Učitaš podatke iz filea u neko polje. Zatim u petlji ides bajt po bajt kroz to polje i stavljaš bajtove u buffer za slanje. Kad naiđes na \\n , u istoj iteraciji stavi \\r zatim \\n u buffer.",
      "votes": {
        "upvoters": [
          "Gussy (huba buba)"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19976": {
      "poster": "Cvija",
      "content": "A kako se postiže konkurentnost?\n\nJel moram raditi one forkove pa da svako dijete obrađuje svakog klijenta ili postoji neki drugi način?\n\nU TFTP-u u knjizi se spominje neka konkurentnost mijenjanjem portova prilikom slanja paketa",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "19979": {
      "poster": "Sashat_Triceps (Sasha_Triceps)",
      "content": "@Cvija#19976 Sa dretvama ti je najjednostavnije, svaka dretva obrađuje jednog klijenta i stvara novi socket. S time postižeš i konkurentnost opisanu u tftpu ( tftp server prima zahtjeve na jedan port, ali odgovara na drugom)",
      "votes": {
        "upvoters": [
          "Cvija"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20084": {
      "poster": "Cvija",
      "content": "A kako si provjeravao je li netascii ili octet u poruci koju prima prilikom RRQ?\n\nJer meni nekako sve proguta u filename",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20097": {
      "poster": "Cvija",
      "content": "@Cvija#20084 Napravio sam strukture koje pokrivaju svaki dio\n\nOvako mi izgleda struktura koja pokriva dio za primanjem zahtjeva:\n\n`struct tftp_rrq{\n\nuint16_t code;\n\nuint8_t filename[512];\n\nuint8_t zero;\n\nuint8_t mode[30];\n\nuint8_t zero2;\n\n};`",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20105": {
      "poster": "Sashat_Triceps (Sasha_Triceps)",
      "content": "@Cvija#20097 Ovako mi izgleda struktura za primanje zahtjeva : \n\n`\n\nstruct RRQbuffer{\n\n\tu_int16_t code;\n\n\tchar fileNameAndMode[100];\n\n\t};\n\t\n`\n\nKasnije u kodu sa strtok-om i  u programu izdvojis filename i mode, a strcmp-om usporedis string u modeu s \"netascii\", odnosno \"octet\"",
      "votes": {
        "upvoters": [
          "Cvija"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20126": {
      "poster": "Gussy (huba buba)",
      "content": "@Cvija#20097 problem ti je što taj rrq paket nema određenu dužinu i koliko sam ja razumio iz specifikacije, ta dva \"zero\" dijela paketa su zapravo `\\0`.",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20128": {
      "poster": "Gussy (huba buba)",
      "content": "@Sashat_Triceps#19972 Jel misliš sve podatke iz filea staviti u jedno polje?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20167": {
      "poster": "Sashat_Triceps (Sasha_Triceps)",
      "content": "@Gussy#20128 Ne , mislim da učitavaš po dijelovima u polje. Fileovi su reda veličina nekoliko MB što uzima dosta memorije ako bi ga cijelog išao učitavat. Uzmeš polje od tipa 4KB, učitaš dio podataka u njega i obrađuješ ga. Kad ga obradiš uzmeš novi dio itd itd",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20409": {
      "poster": "Cvija",
      "content": "@Sashat_Triceps#20105 E vidiš, kad tako primim podatak, problem mi je što se u filenameimode spremi samo filename\n\nMode se ne spremi",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20410": {
      "poster": "Cvija",
      "content": "@Cvija#20409 [EDIT] riješio\n\nAko netko ima takav problem, može npr. uzeti strlen od toga i na to mjesto postaviti neki delimiter s kojim će kasnije podijeliti string",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "20807": {
      "poster": "Cvija",
      "content": "Treba li program nakon primanja datoteke se zatvoriti ili nastaviti s radom?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "28053": {
      "poster": "angello2",
      "content": "Nisam napiso ovu zadacu na vrijeme misleci da nije obavezno sve predat al jbg sad imam 1 dan za napisat ovaj tftp, jeste vi samo isli po onom tftpserveru koji izade na necijem githubu kad guglas tftpserver ili ste fakat samostalno ovo pisali? Cini mi se pun kurac komplicirano a nemam bas puno vremena, imate neki hint?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    }
  }
}