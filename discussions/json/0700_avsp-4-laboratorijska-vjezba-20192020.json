{
  "title": "[AVSP] 4. laboratorijska vježba - 2019/2020",
  "creator": "xeqte",
  "slug": "avsp-4-laboratorijska-vjezba-20192020",
  "tags": [
    "FER",
    "Analiza velikih skupova podataka",
    "Laboratorijske vježbe"
  ],
  "posts": {
    "27338": {
      "poster": "xeqte",
      "content": "Ispada li još kome u prvom integracijskom testu za A zadatak dobiveni izlaz prazan? Za ostale mi normalno i ispravno ispise rezultate. Može li biti možda do vremena izvođenja?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "27357": {
      "poster": "caffeine",
      "content": "Do vremena izvođenja je vjerojatno, meni je isto tak bilo.",
      "votes": {
        "upvoters": [
          "Ellie",
          "xeqte"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "27890": {
      "poster": "xeqte",
      "content": "Ako nekome pomogne, (mozda je drugima ocito, meni nije bilo) nakon puno uzaludnog optimiziranja koda, pokusao sam ispitati konvergenciju, tj. jeli se za svaki čvor, rang promjenio od posljednje iteracije i ispada da vec nakon nekoliko iteracija svi rangovi čvorova konvergiraju. Onda se za upite gdje se trazi veca iteracija, ispise rang pri konvergenciji.",
      "votes": {
        "upvoters": [
          "Amali (Amajli)",
          "Ellie",
          "volimfmos69 (debos)"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "29628": {
      "poster": "doakes",
      "content": "Je li netko imao  Memory error kad je stvarao matrice gdje je N=100 000 ?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "29632": {
      "poster": "logitech",
      "content": "Malo upadam ne informiran sa gradivom za ovaj labos. Na kojem se točno slajdu predavanja nalazi algoritam kojeg moramo implementirati za A) zadatak?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "29638": {
      "poster": "xeqte",
      "content": "@logitech#29632 ![](assets/2020-05-24/00034.png)\n\nJa sam implementirao ovaj algoritam (48. slajd) ali umjesto uvjeta u ovoj do while petlji gledam je li ima razlike kada se broj ispise u 10 decimala izmedu rj(t+1) i rj(t) za svaki cvor.\n\n@doakes#29628 Mozda ako stvaras nove strukture podataka za svaku iteraciju algoritma dobijes taj error. probaj ispitati konvergenciju algoritma (ne moraju se proci sve iteracije).",
      "votes": {
        "upvoters": [
          "Amali (Amajli)",
          "logitech"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "29819": {
      "poster": "Ana96",
      "content": "Jel zna netko koje se predavanje odnosi na 4.B zadatak?",
      "votes": {
        "upvoters": [
          "Paula13 (p13)"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "29850": {
      "poster": "caffeine",
      "content": "@Ana96#29819 Koliko sam ja shvatila ni na jedno previše, nego su to eto tako stavili jer ima veze s grafovima. Neka me netko ispravi ako sam u krivu, nisam baš pratila gradivo nakon MI-ja.",
      "votes": {
        "upvoters": [
          "Amali (Amajli)",
          "Ana96"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "29896": {
      "poster": "leo (tajler)",
      "content": "jel netko zna do čega može biti pogreška stderr na kraju u sprutu za A dio zadatka, a ispis je točan? čak i prolazi za 2/4 testa, pisano je  u javi",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "29971": {
      "poster": "leo (tajler)",
      "content": "do konvergencije je bio problem, treba staviti barem 10e-15 i tek onda prekinuti petlju računanja rangova",
      "votes": {
        "upvoters": [
          "Amali (Amajli)"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30003": {
      "poster": "Kristijan",
      "content": "@leo#29896 ![](assets/2020-05-25/00034.png)\n\nNeznam ak si na ovo mislio, ali ja dobivam pogrešku zato što mi se program izvađa više od 60s na najvećem primjeru. Inače mi daje točne rezultate. Možda je i tebi u tome problem.",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30032": {
      "poster": "doakes",
      "content": "@xeqte#29638  Da, ali problem mi bude kad idem  stvoriti pocetnu matricu preko np.zeroes(N,N) N=1000000, nemoze je pohraniti  u memoriji pa neznam kako da radim sa matricom koja nemoze bit pohranjena",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30036": {
      "poster": "neytiri",
      "content": "@doakes#30032 u predavanju par slajdova nakon algoritma imas pseudokod za slucaj kad ti matrica ne stane u radnu memoriju",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30058": {
      "poster": "Kristijan",
      "content": "@neytiri#30036 Ja sam probao s tim algoritmom ali mi se izvodi dosta sporo. Da nema ovog ograničenja od 60s bilo bi sve super",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30062": {
      "poster": "neytiri",
      "content": "@Kristijan#30058 \n\nja sam spremila sve iteracije u matricu, mislim da mi je to u najgorem slucaju matrica 100 000 x 100 tipa float i stala mi je u memoriju. onda sam za svaki query samo ispisala rezultat vec napisan u matrici iteracija. znam da nije bas najbolje rjesenje, ali mi ubrza toliko da prolazi na sprutu, a ne baca mi memory error",
      "votes": {
        "upvoters": [
          "Amali (Amajli)",
          "Kristijan"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30080": {
      "poster": "xeqte",
      "content": "@doakes#30032 ja sam radio pomocu dictionarya, tako da stvaranje novog retka u matrici (nove iteracije) spremam pod kljuc koji je index retka. time se stvaraju retci redom i ne treba zauzimati sav prostor na pocetku.",
      "votes": {
        "upvoters": [
          "Amali (Amajli)"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30082": {
      "poster": "Kristijan",
      "content": "Evo ako se neko još bori sa vremenskim ograničenjem. Predlažem korištenje _sparse matrica_ iz _scipy_-a (https://docs.scipy.org/doc/scipy/reference/sparse.html#sparse-matrices-scipy-sparse) za skladištenje matrice **M** (štedi jako puno prostora). Ja sam konkretno koristio _csr_ jer je dobra za matrično množenje. Koristio sam formulu ![](assets/2020-05-25/00040.png)\n\n, i cijela se stvar (bez ispisivanja) vrti cca. 1,5 s.",
      "votes": {
        "upvoters": [
          "Amali (Amajli)",
          "adrian7000"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30099": {
      "poster": "Amali (Amajli)",
      "content": "@doakes#30032 \n\nJa ne cuvam matricu neg cuvam dict, radim u Pythonu\n\n@xeqte#30080 radim ovako isto I guess, ako dobro shvacam ovo\n\ndakle za poveznice imam dict koji punim dok citam podatke - kljuc mi je node u kojeg se ide, value mi je lista cvorova koji ulaze u njega (note - tu nece bit svi nodeovi pa treba u funkciji iterirat bas i od 0 do N-1). Nemam problema s memorijom\n\nza rangove imam sam onak dva 100k,1 numpy arraya i stvorim ih samo na pocetku i resetiram i mijenjam vrijednosti oduzimanjem i dodavanjem vrijednosti da ne stvaram novo nit kopiram pa du dobivam na brzini\n\nmeni se ne vrti bas 1,5s al se vrti 30-40s (ispis u txt tho al nikad mi moj print nije bas puno uzimao do sad no vidjet cemo, mada vjerujem da oni preusmjere u fajl? cini se da da jer mi prolazi sve na sprutu) na najvecem primjeru koji smo dobili and that's good enough for me\n\nqueryje isto cuvam i onda zovem pagerank funkciju samo jednom (za svaku iteraciju provjeravam jel u nekom queryju), ne znam jel i drugi to rade? ako da, kul, ako ne, eto moze bit dobar tip",
      "votes": {
        "upvoters": [
          "xeqte"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30108": {
      "poster": "Dujma8",
      "content": "Kako ste rjesili ovaj problem s pohranom matrice N=100000. Ja pisem u Javi. Odmah mi na pocetku izvođenja javi problem da nema memorije",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30113": {
      "poster": "Amali (Amajli)",
      "content": "@Dujma8#30108 koliki ti je ram? Postoje ti u prezi tips and tricks ako ti bas nis ne stane nigdje, skroz na kraju imas slucaj di matrica ne stane al vektori ranga stanu, a i slucaj kad nijedno bas ne stane pa pogledaj ak nisi. Pocinje na slajdu 54 za ovaj najgori da ni matrica ni vektori ranga ne stanu. Isto tako mozes pogledat da koristis dictionary nekako ko ja pa ne moras toliko toga pamtiti",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30123": {
      "poster": "SergeantPepper (Chet)",
      "content": "@Dujma8#30108 Očekivano je da javi da nema memorije zato što je ideja *ne* koristiti matricu (svaki čvor \"pokazuje\" na maksimalno 15 drugih!)\n\nJedino što ti treba za svaki vrh (čvor) grafa su indeksi čvorova na koje on pokazuje.\n\nTo u Javi možeš riješiti na veliki broj načina, npr. korištenjem HashMape koja će za ključ imati index izvorišnog čvora, a kao vrijednost listu/polje indeksa odredišnih čvorova ili korištenjem liste lista koja će na indeksu *idx* imati listu indeksa odredišnih čvorova za *idx*",
      "votes": {
        "upvoters": [
          "Bananaking",
          "Red_Baron"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30403": {
      "poster": "Jim",
      "content": "@neytiri#30062 meni takav pristup ne prolazi za ovaj najveci file.. jel mi mozes napisat sta si radila da to dodatno optimiziras? ja npr koristim default dict i doslovno sve radim po ovom presudoku sa preze ali umjesto uvjeta za konvergenciju imam uvjet da se to radi do 100. iteracije. ne znam kak to ubrzat za taj najveci primjer",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30414": {
      "poster": "xeqte",
      "content": "za najveci primjer (btest), konvergencija se dogodi pri 17. iteraciji, tako da je racunanje svih ostalih 83 iteracija nepotrebno i oduzima previse vremena. probaj nakon svake iteracije usporediti rangove svih čvorova sa rangovima za te čvorove iz prošle iteracije, ako se nijedan nije promijenio, znači da neće ni nakon iduće iteracije, tj. slobodno zaustavi program i spremi broj iteracije. onda svaki put kada se trazi rang čvora na iteraciji većoj od te, pošalji rang na spremljenoj iteraciji. za manje primjere (ako radite svih 100 iteracija) mislim da se to dogodi oko 50-te iteracije tako da nemojte hard-codat broj iteracija ispod 100.\n\n@Jim#30403",
      "votes": {
        "upvoters": [
          "Jim",
          "neytiri"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30679": {
      "poster": "Bananaking",
      "content": "Jel uspio netko izvritit btest na svom racunalu ispod 60 sekundi?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30681": {
      "poster": "cvitaa",
      "content": "Zna li netko je li potrebno u A zadatku računati leaked importance, piše u zadatku da nema dead end cvorova?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30686": {
      "poster": "xeqte",
      "content": "@cvitaa#30681 mislim da ovisi samo o tome koju varijantu algoritma implementiras, moguce je dobiti ispravan rezultat na vise nacina.\n\n@Bananaking#30679 procitaj moj post povise, bez problema se vrti btest za nekih 20-ak sekundi",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30716": {
      "poster": "Bananaking",
      "content": "> @xeqte#30686 procitaj moj post povise, bez problema se vrti btest za nekih 20-ak sekundi\n\n@xeqte#30686 Ne razumijem bas ovo hardkodiranje?\n\nJa ako otkrijem konvergiranje sacuvam snapshot svih rangova u toj iteraciji i proslih i ispisem rezultat. Za svaki iduci upit za konvergenciju jednaku ili vecu, ucitam taj snapshot, pogledam jel tada konvergirao ako da ispisem, ako ne nastavljam od njega (da ne krecem ispocetka) i dalje ako konvergira na visoj iteraciji sacuvam nju. To je ubrzalo upite za vece iteracije (ispade 16 iteracija najveca). Onda sam ubrzao za manje iteracije od 16. tako da sacuvam u memoriji rangove svih cvorova za tu iteraciju (3, 4, 5, 6...) pa kad trazi za nesto ispod 16 uvijek pogledam u memoriju i samo izvadim rezultat.\n\nOvdje je kraj ispisa za btest. Prvi upit naravno traje dulje (6 sekundi) Nek je vrijeme svakog querya 1 milisekunda recimo, ima ih 100000 nemoze mi biti ispod 60 sekundi (ili bolje 20) nikako. Dobro nesto vremena ide na ispis u file ali svejedno.\n\n![](assets/2020-05-27/00021.png)",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30735": {
      "poster": "xeqte",
      "content": "@Bananaking#30716 Ma hardkodiranje sam samo naveo da ne bi netko racunao samo do recimo 20-te iteracije svaki primjer jer bi to radilo samo za primjere koji konvergiraju prije te iteracije, a to nije slucaj kod svih primjera.\n\nSto se tice vremena izvodenja, nisam siguran jeli razumijem, da li prvo racunas rangove svih cvorova do konvergencije ili tek kad za njih dode upit? ono sto ja radim je prije nego pocnem ucitavat upite, pokrenem algoritam na max 100 iteracija, provjeravam kod svake konvergenciju i ako se rangovi nisu promijenili prekinem algoritam. Tek onda pocinjem ucitavat upite i ispisujem rezultate koje sam vec izracunao. Ti izracuni su zapisani u dictionary, tako da vrijeme je vrijeme dohvata uvijek o(1) notaciji, tj. ne trosi nepotrebno vrijeme.\n\n![](assets/2020-05-27/00025.png)\n\nmoj ispis btest primjera",
      "votes": {
        "upvoters": [
          "Bananaking",
          "Nabas"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30746": {
      "poster": "Bananaking",
      "content": "> @xeqte#30735 da li prvo racunas rangove svih cvorova do konvergencije ili tek kad za njih dode upit? ono sto ja radim je prije nego pocnem ucitavat upite, pokrenem algoritam na max 100 iteracija, provjeravam kod svake konvergenciju i ako se rangovi nisu promijenili prekinem algoritam\n\nOk, sad razumijem sto hoces reci. Ja vrtim za svaki upit algoritam ali nakon prvog koji konvergira u toj famoznoj 17 iteraciji, u memoriji imam rankove za sve cvorove u svim iteracijama do 17 i za svaki upit gledam jel ti treba vise ili jednako od 17 -> nastavi od 17, jel ti treba manje od 17 -> procitaj iz memorije",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30753": {
      "poster": "xeqte",
      "content": "@Bananaking#30746 aha, razumijem. sad probaj za svaki upit koji trazi iteraciju vecu od 17, takoder ispisat iz memorije, ali rang pri 17. iteraciji (ne treba pokretati algoritam za iteracije iza konvergencije jer sve ostaje isto)",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30857": {
      "poster": "Dujma8",
      "content": "Jel težak ovaj B zadatak. Kolko treba da ga se riješi?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "30884": {
      "poster": "ton6 (toto6)",
      "content": "Jel radio itko na ovakav način, krivi su mi rezultati (neki ispadnu veći od 1)? Obzirom da sam spremala u dict ovo mi se činilo kao najjednostavnije ali...\n\n![](assets/2020-05-27/00042.png)",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "31191": {
      "poster": "Amali (Amajli)",
      "content": "@Dujma8#30857 u pythonu, meni je trebalo oko dva sata a rjesavala sam bolesno chill tempom uz pauzice il paralelno vodjenje razgovora o pedesetim temama, i to nakon vec 4.5h rjesavanja A zadatka oko kojeg sam se vise mucila s bugovima i prepravljanjem i istrazivanjem opcija i slaganjem struktura. Rekla bih, dakle, dost easy, doduse ja sam ganjala sve slucajeve da preskacem dijelove izvodjenja koji su mi bespotrebni pa ak to nije nuzno da zadovolji vremensko ogranicenje gotovo je i u manje vremena",
      "votes": {
        "upvoters": [
          "Dujma8"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [
          "adidas"
        ],
        "wtf": [],
        "tuga": []
      }
    },
    "31231": {
      "poster": "addisonRae",
      "content": "Vi koji ste uspjeli da vam test sa 100.000 čvorova ide ispod 60s, koliko vam treba za primjer od 1000 čvorova (meni je oko 600ms) ?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "31326": {
      "poster": "Bananaking",
      "content": "@addisonRae#31231 Nakon hrpe vremena i živaca ovako - nemoj računati iteracije koje si već izračunao, pazi kako ispisuješ (bufferedWriter), ako je konvergirao nemaš što računati i zvati funkciju, samo u memoriji trebaš imati sve rangove za iteracije do te u kojoj je konvergirao (za btest to je ta magična 17. iteracija) i onda ako je zahtjev za manjom (recimo 9.) izvučeš iz memorija[9][trazeni_indeks] ako je za vecom recimo 56 izvuces iz memorija[17][trazeni_indeks].\n\nNaravno mozes imati neke provjere da tada i trazena vrijednost konvergira, kolega gore je vrtio sve dok bas svi indeksi ne konvergiraju pa pamti do te vrijednosti, kako god zelis ali svodi se na to da ne pozivas funkciju a pogotovo ne racunas iteracije koje si vec izracunao. Sretno.",
      "votes": {
        "upvoters": [
          "addisonRae"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "31371": {
      "poster": "Dujma8",
      "content": "@Amali#31191 kak si spremala matricu susjedstva ?",
      "votes": {
        "upvoters": [],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    },
    "31444": {
      "poster": "Amali (Amajli)",
      "content": "@Dujma8#31371     imam dictionary, kljuc je indeks nodea, value je lista susjeda, doable i s listom jer su samo indeksi al to mi je bilo kompliciranje iskemijat",
      "votes": {
        "upvoters": [
          "Dujma8"
        ],
        "downvoters": []
      },
      "reactions": {
        "haha": [],
        "wtf": [],
        "tuga": []
      }
    }
  }
}